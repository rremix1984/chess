# 象棋游戏设计文档

## 1. 总体设计

本项目旨在开发一款功能完善的中国象棋对弈游戏。项目将采用面向对象的设计思想，分为以下几个核心模块：

-   **核心逻辑模块 (`core`)**: 负责处理游戏的核心规则，包括棋盘管理、棋子移动、规则校验、游戏状态判断等。该模块将独立于UI，保证其可重用性和可测试性。
-   **图形用户界面模块 (`ui`)**: 负责游戏的视觉呈现和用户交互。将使用 Java Swing 或 JavaFX 技术栈，为用户提供一个直观、友好的游戏界面。
-   **主程序模块 (`main`)**: 负责整合核心逻辑和UI模块，启动并运行整个游戏程序。

## 2. 数据结构设计

### 2.1. 棋盘 (`Board`)

棋盘将使用一个二维数组来表示，例如 `Piece[][] board = new Piece[10][9];`，其中：

-   10 表示棋盘的行数（0-9）。
-   9 表示棋盘的列数（0-8）。
-   数组中的每个元素存放一个 `Piece` 对象，如果某个位置没有棋子，则对应元素为 `null`。

### 2.2. 棋子 (`Piece`)

每个棋子都是一个对象，包含以下属性：

-   `type`: 棋子类型 (例如，車, 馬, 炮, 象, 士, 將, 兵)。
-   `color`: 棋子颜色 (红色或黑色)。
-   `position`: 棋子在棋盘上的坐标。

### 2.3. 走法 (`Move`)

一个走法对象用于记录一步棋的操作，包含：

-   `startPosition`: 棋子移动的起始位置。
-   `endPosition`: 棋子移动的目标位置。
-   `piece`: 被移动的棋子。
-   `capturedPiece`: 如果有吃子发生，记录被吃的棋子。

## 3. 核心类设计

### 3.1. `Game.java`

-   **职责**: 管理整个游戏的状态和流程。
-   **属性**:
    -   `Board board`: 当前的棋盘状态。
    -   `Player redPlayer`, `Player blackPlayer`: 两位玩家。
    -   `Player currentPlayer`: 当前回合的玩家。
    -   `GameState state`: 游戏当前的状态 (例如, `PLAYING`, `CHECKMATE`, `STALEMATE`)。
-   **方法**:
    -   `startGame()`: 初始化游戏。
    -   `makeMove(Move move)`: 执行一步棋，并更新游戏状态。
    -   `switchPlayer()`: 切换当前玩家。
    -   `isGameOver()`: 判断游戏是否结束。

### 3.2. `Board.java`

-   **职责**: 管理棋盘数据和棋子的布局。
-   **属性**:
    -   `Piece[][] pieces`: 存储所有棋子的二维数组。
-   **方法**:
    -   `getPiece(int x, int y)`: 获取指定位置的棋子。
    -   `setPiece(int x, int y, Piece piece)`: 在指定位置放置一个棋子。
    -   `movePiece(Position start, Position end)`: 移动棋子。
    -   `initializeBoard()`: 初始化棋盘到开局状态。

### 3.3. `Piece.java` (抽象类)

-   **职责**: 所有棋子类型的基类，定义了棋子的通用属性和行为。
-   **属性**:
    -   `PieceColor color`: 棋子颜色。
-   **方法**:
    -   `abstract boolean isValidMove(Board board, Position start, Position end)`: 校验走法是否符合规则（由子类实现）。

#### 3.3.1. 棋子子类

将为每种棋子创建一个具体的子类，继承自 `Piece`，并实现其特定的移动规则：

-   `General.java` (将/帅)
-   `Advisor.java` (士)
-   `Elephant.java` (象)
-   `Horse.java` (马)
-   `Chariot.java` (车)
-   `Cannon.java` (炮)
-   `Soldier.java` (兵)

### 3.4. `Player.java`

-   **职责**: 代表参与游戏的玩家。
-   **属性**:
    -   `String name`: 玩家名称。
    -   `PieceColor color`: 玩家所执棋子的颜色。

## 4. 游戏流程

1.  **启动游戏**: `main` 方法创建 `Game` 对象和UI窗口。
2.  **初始化**: `Game` 对象调用 `board.initializeBoard()` 来摆放初始棋子。
3.  **等待用户输入**: UI界面等待当前玩家点击棋子。
4.  **选择棋子**: 玩家点击自己的一个棋子，UI高亮该棋子及所有合法可走的位置。
5.  **移动棋子**: 玩家点击一个合法目标位置。
6.  **执行走法**: UI将这个走法 (`Move` 对象) 发送给 `Game` 对象。
7.  **更新状态**: `Game` 对象调用 `makeMove()` 方法，更新棋盘状态，切换玩家，并检查游戏是否结束。
8.  **刷新界面**: UI根据 `Game` 对象的新状态重新绘制棋盘。
9.  **循环**: 重复步骤 3-8，直到游戏结束。
10. **游戏结束**: 当 `isGameOver()` 返回 `true` 时，UI显示游戏结果（胜利、失败或和棋）。

## 5. 已完成功能

### 5.1. 核心逻辑模块 ✅

- **棋盘管理 (`Board.java`)**: 
  - 实现了10x9的棋盘数据结构
  - 提供了获取、设置、移动棋子的方法
  - 完成了初始棋盘布局的设置

- **棋子基类 (`Piece.java`)**: 
  - 定义了抽象基类，包含颜色属性和抽象移动验证方法
  - 提供了获取中文名称的抽象方法

- **具体棋子类**: 
  - `General.java` (将/帅): 实现了九宫格内移动规则
  - `Advisor.java` (士): 实现了九宫格内斜向移动规则
  - `Elephant.java` (象): 实现了田字移动和不过河规则
  - `Horse.java` (马): 实现了日字移动和蹩马腿规则
  - `Chariot.java` (车): 实现了直线移动和路径检查规则
  - `Cannon.java` (炮): 实现了炮架吃子和直线移动规则
  - `Soldier.java` (兵): 实现了过河前后不同的移动规则

### 5.2. 图形用户界面模块 ✅

- **游戏主窗口 (`GameFrame.java`)**: 
  - 创建了800x950像素的游戏窗口
  - 添加了状态栏显示当前玩家信息
  - 实现了状态更新回调机制

- **图形用户界面模块 (`BoardPanel.java`)**: 
  - 绘制了标准的中国象棋棋盘，包括九宫格和楚河汉界
  - 实现了棋子的可视化显示，红黑双方用不同颜色区分
  - 添加了鼠标点击事件处理
  - 实现了棋子选择高亮显示
  - 完成了基本的移动交互逻辑
  - 实现了合法走位提示功能，选中棋子时显示绿色圆点标记
  - **AI交互逻辑**：处理AI回合、状态显示、异步移动执行

### 5.3. 用户交互功能 ✅

- **棋子选择**: 点击己方棋子进行选择，选中的棋子会有黄色高亮边框
- **棋子移动**: 选中棋子后点击目标位置进行移动
- **移动验证**: 集成了各棋子的移动规则验证
- **玩家切换**: 每次有效移动后自动切换当前玩家
- **状态显示**: 实时显示当前轮到哪方下棋
- **合法走位提示**: 选中棋子时显示所有可移动位置的绿色圆点

## 6. 当前进度

### 6.1. 已实现的核心功能
- ✅ 完整的棋盘数据结构
- ✅ 所有7种棋子的移动规则
- ✅ 基本的图形界面
- ✅ 鼠标交互和棋子移动
- ✅ 玩家轮换机制
- ✅ 移动合法性验证

### 6.2. 最新完成功能 ✅

#### 获胜条件检测功能
刚刚实现了完整的游戏结束逻辑，让象棋游戏具备了标准的获胜条件检测：

**核心特性**：
- **完整的游戏结束逻辑**: 实现了标准象棋的所有获胜条件
  - **将死检测**: 当一方将军被将军且无法逃脱时，对方获胜
  - **将军被吃**: 当一方的将军被直接吃掉时，对方立即获胜
  - **困毙检测**: 当一方无法移动但未被将军时，判定为和棋
  - **将军状态**: 正确识别和显示将军状态，但游戏继续
- **智能移动验证**: 
  - 防止玩家进行会导致己方将军被将军的移动
  - 实时检查每次移动的安全性
  - 确保游戏规则的严格执行
- **用户体验优化**:
  - 游戏结束时弹出获胜对话框
  - 提供重新开始游戏选项
  - 游戏结束后禁止继续移动
  - 支持AI和人类玩家的获胜检测
- **技术实现**:
  - 棋盘状态模拟和回滚机制
  - 高效的将军检测算法
  - 完整的游戏状态枚举（PLAYING, IN_CHECK, RED_WINS, BLACK_WINS, DRAW）

#### AI对弈功能
之前实现了完整的AI对弈系统，让玩家可以与智能AI进行象棋对战：

**核心特性**：
- **智能AI引擎**：基于极小极大算法（Minimax）实现决策
- **Alpha-Beta剪枝**：优化AI计算性能
- **4个难度等级**：简单、普通、困难、专家
- **智能评估函数**：考虑棋子价值和位置优势
- **用户友好界面**：AI控制面板，可选择玩家颜色和AI难度
- **实时状态显示**：人类/AI回合，AI思考状态
- **后台线程处理**：避免UI阻塞，提供流畅体验

### 6.3. 待完善的功能

#### 6.3.1. 游戏规则完善 🔄
- [ ] 将军检测：检测是否将军对方
- [ ] 应将处理：被将军时必须应将
- [ ] 胜负判断：将死、困毙等游戏结束条件
- [ ] 特殊规则：长将、长捉等和棋规则

#### 6.3.2. 用户体验优化 🔄
- [ ] 移动历史：记录和显示走棋历史
- [ ] 悔棋功能：允许玩家撤销上一步操作
- [ ] 音效添加：移动、吃子、将军等音效

#### 6.3.3. 界面美化 🔄
- [ ] 更精美的棋盘和棋子设计
- [ ] 动画效果：棋子移动动画
- [ ] 主题切换：不同的棋盘和棋子主题
- [ ] 响应式布局：适配不同屏幕尺寸

#### 6.3.4. 高级功能 📋
- [ ] 网络对战：支持在线对弈
- [ ] 棋谱保存：保存和加载游戏记录
- [ ] 复盘功能：回放历史对局

## 7. 技术架构

### 7.1. 项目结构
```
src/main/java/com/example/
├── core/                    # 核心逻辑模块
│   ├── Board.java          # 棋盘管理
│   ├── Piece.java          # 棋子基类
│   ├── PieceColor.java     # 棋子颜色枚举
│   ├── Position.java       # 位置坐标
│   ├── General.java        # 将/帅
│   ├── Advisor.java        # 士
│   ├── Elephant.java       # 象/相
│   ├── Horse.java          # 马
│   ├── Chariot.java        # 车
│   ├── Cannon.java         # 炮
│   └── Soldier.java        # 兵/卒
├── ai/                     # AI对弈模块 ✅
│   ├── ChessAI.java        # AI引擎核心
│   └── Move.java           # 移动表示类
├── ui/                     # 用户界面模块
│   ├── GameFrame.java      # 主窗口（含AI控制面板）
│   └── BoardPanel.java     # 棋盘面板（含AI交互）
└── App.java                # 主程序入口
```

### 7.2. 设计模式应用
- **策略模式**: 每种棋子的移动规则作为独立的策略实现
- **观察者模式**: UI组件监听游戏状态变化
- **工厂模式**: 可用于创建不同类型的棋子
- **命令模式**: 可用于实现悔棋功能

### 7.3. 代码质量保证
- **边界条件检查**: 所有移动验证都包含边界检查
- **异常处理**: 对无效操作进行适当的异常处理
- **代码复用**: 通过继承和接口实现代码复用
- **可扩展性**: 模块化设计便于功能扩展

### 7.4. AI对弈模块 ✅

#### 7.4.1. ChessAI（AI引擎）
- **核心算法**：极小极大算法（Minimax）+ Alpha-Beta剪枝
- **评估函数**：棋子价值 + 位置加分 + 棋盘控制力
- **难度控制**：通过搜索深度调节（1-4层）
- **性能优化**：剪枝算法减少搜索空间

#### 7.4.2. Move（移动表示）
- 封装棋子移动的起始和结束位置
- 提供标准的equals、hashCode和toString方法
- 支持移动的比较和调试输出

#### 7.4.3. AI集成特性
- **异步处理**：使用SwingWorker避免UI阻塞
- **状态管理**：完整的棋盘状态复制和恢复
- **智能延迟**：模拟真实思考时间
- **用户体验**：实时状态反馈和流畅交互

### 7.5. 开发规范

#### 7.5.1. 代码规范
- 使用Java标准命名规范
- 类名使用PascalCase
- 方法和变量使用camelCase
- 常量使用UPPER_SNAKE_CASE

#### 7.5.2. 注释规范
- 类和方法添加JavaDoc注释
- 复杂逻辑添加行内注释
- 保持注释与代码同步更新